---
layout: post
title: "算法"
date: 2019-07-19
categories: 算法
tags: 算法
author: mzz
---

- content
  {:toc}

## 目的

了解数据结构、算法思想、优缺点、合理运用到项目中，
常见算法：

## 数据结构

了解各类数据结构在内存的存储模型。

### 数组

    连续分配的存储区域（连续的内存空间）

    如果没有足够连续分配的存储空间，则不能够成功常见数组对象。

    特性：随机查找速度快 O(1),插入效率低O（n)  -->Why？

### 链表

    可以是非连续的存储区域

    特性：顺序查找 O(n),插入、删除 O（1)  -->Why？

    扩展：实例：点餐服务 ------> 插入、删除效率高

### 栈

    调用栈： 后进先出（先进后出）
    调用栈可能很长，需要占用很多的内存     --->竖着的 长方形
    不能用于查找

    优化：采用循环、尾递归

    扩展：思考代码中方法名称、参数名称 存放的位置

    实例：递归算法

### 队列

    实例：公交车站，排队等车
    特点：先进先出

### 散列表

     内部机制： 实现、冲突、散列函数

     散列函数：
        <1.它必须是一致的（同一输入，输出结果相同）
        <2.它应将不同的输入映射到不同的数字 ** （没有冲突的情况） 很难

       （1）散列函数很重要（最理想的情况：将键均匀映射到散列的不同位置）
       （2）散列的链表不能太长，影响查询效率

     实例： HashTable、HashMap

        <1.模拟映射关系 -->将散列用于查找 （通过姓名查询电话号码）
        <2.防止重复（投票站投票，不允许1人多投）
        <3.将散列用于缓存（网站缓存，不用每次请求服务器）

    性能：

        1.较低的填充因子（散列包含的元素个数/位置总数）
        2.良好的散列函数（各个语言内置有散列函数）

### 图

    图有节点和边组成。

#### 有向图

    有方向，单向关系

#### 无向图

    无方向

#### 树

    树是一种特殊的图。
    实例：家谱

## 算法

### 二分法查找

        有序的数组，效率 O(logn)

        实例： 猜数字 100 ，需要猜多少次 （log128)

        对数与幂运算互为逆运算。（幂运算表示指数个底数相乘）

### 快速排序

    D&C 分而治之的思想，欧几里德算法（辗转相除法）   递归的思想

    基线条件：数组为空或者只有一个元素时  （类似与初中时给函数并找规律）

    实例：农场主分地问题  1680 X 640 --> 640 X 400 --> 240 X 400 --> 240 X 160 --> ..

### [合并排序](https://baike.baidu.com/item/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/2669171?fr=aladdin)

```
将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
```

```java
public static void mergeSort(int[]array){

  int length=array.length;
  int middle=length/2;

  if(length>1){
    int[]left=Arrays.copyOfRange(array,0,middle);//拷贝数组array的左半部分
    int[]right=Arrays.copyOfRange(array,middle,length);//拷贝数组array的右半部分
    mergeSort(left);//递归array的左半部分
    mergeSort(right);//递归array的右半部分
    merge(array,left,right);//数组左半部分、右半部分合并到Array
  }
}

//合并数组，升序
private static void merge(int[]result,int[]left,int[]right){

  int i=0,l=0,r=0;

  while(l<left.length&&r<right.length){
    if(left[l]<right[r]){
      result[i]=left[l];
      i++;
      l++;
    }else{
      result[i]=right[r];
      i++;
      r++;
   }
  }

  while(r<right.length){//如果右边剩下合并右边的
    result[i]=right[r];
    r++;
    i++;
  }

  while(l<left.length){
    result[i]=left[l];
    l++;
    i++;
  }
}
```

### 广度优先搜索

```
用图的查找算法，主要解决两类问题：

  <1.从节点A出发，有前往节点B的路径吗？
  <2.从节点A出发，前往节点B的哪条路径最短？（段数/边最少的路径）
```

实例：在人际圈中查找水果经销商 --你的人际圈（一度关系）、你朋友的人际圈（二度关系）、朋友的朋友的人际圈（三度关系）

### 狄克斯特拉

    找出最快到达目的地的路径。（所用时间最少的路径）

    区别广度优先搜索：找出段数最少的路径（尽量少转车而达到目的地的路径）

    狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。

    带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。


    **负权边** 时，该算法不使用，可采用[贝尔曼-福德算法（Bellman-Fordalgorithm）]

    实例： 换钢琴

    总结：

      要计算非加权图中的最短路径，可使用广度优先搜索。
      要计算加权图中的最短路径，可使用狄克斯特拉算法(只适应有向无环图)。

### 贪婪算法

    选择每个最优，则全最优。（排课表）

    这是一种近似最优的算法（背包问题：最多拿10千克重的物品，请选择价值最大的。 10kg 6000元的音响、4kg 5000元的笔记本电脑、6kg 2000元的手提琴，通过贪婪算法，结果会选出10kg 6000元的音响，而 后面两者之后大于6000元的音响的价值。）

## 参考

<<算法图解>>

[合并排序](https://baike.baidu.com/item/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/2669171?fr=aladdin)

[贝尔曼-福德算法（Bellman-Fordalgorithm）](https://baike.baidu.com/item/Bellman-Ford%E7%AE%97%E6%B3%95/1089090?fr=aladdin)
